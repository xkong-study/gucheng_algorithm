求出前缀和之后,需求：j>1&& presum[j]-preSum[i] >=k 最小     
需求的通俗理解：相当于排队，对某个人来说，要找到前面比我矮最少k的人，且我和这个人的距离最近。   
![截屏2024-02-14 22.10.06.png](https://img.xwyue.com/i/2024/02/15/65cd3a46291b1.png)

步骤：  
1.求出前缀和（我们需要在前面多加一个0，可以避免空数组和一个元素数据的情况）
2.单调队列：头用来获取答案，尾部用来维护单调递增的数组（方便获得k的差值）。

```code
var shortestSubarray = function(nums, k) {
    let n = nums.length;
    let prefixSum = new Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }

    let deque = [];
    let count = Infinity;
    for (let i = 0; i <= n; i++) {
        while (deque.length && prefixSum[i] - prefixSum[deque[0]] >= k) {
            count = Math.min(count, i - deque.shift());
        }
        while (deque.length && prefixSum[i] <= prefixSum[deque[deque.length - 1]]) {
            deque.pop();
        }
        deque.push(i);
    }

    return count === Infinity ? -1 : count;
};
```
