<img width="863" alt="截屏2024-02-19 17 38 46" src="https://github.com/xkong-study/gucheng_algorithm/assets/100473178/9a3a3db6-4776-4987-894a-9d6b1f5c0e57">

bubble sort, insertion sort, selection sort, shell sort, quick sort, merge sort, heap sort   
counting sort, bucket sort, radix sort *pancake sort    
215. Kth Largest Element in an Array   
148. Sort List & count of inversion pairs
75. Sort Colors
451. Sort Characters By Frequency
164. Maximum Gap

那些考？那些不考？
常考的：
merge sort,
quick sort (quick select)
bucket sort    
counting sort     
heap sort    
少考的：
pancake sort
不考的：
bubble sort, selection sort, insertion sort, shell sort radix sort。    

归并排序    
归并排序非常适合以下场景或题型：     

稳定排序需求：当需要保持相等元素的原始顺序时，归并排序是一个稳定的排序算法，适合应用。    
大数据集合并：适用于处理大量数据的合并操作，特别是当数据集太大，无法一次性加载到内存中时（外部排序）。
链表排序：归并排序适合于链表这种数据结构，因为它能够在O(logn)空间复杂度下实现，而且不需要随机访问链表节点。    
并行处理：归并排序的分治特性适合并行化处理，可以有效利用多核处理器的计算能力。       

快速选择排序   
快速选择排序适用于以下情况：      
 
堆排序     
适用场景包括：      

不需要稳定排序：与归并排序相比，堆排序不是稳定的排序算法。如果问题不要求保持相同元素的原始顺序，则可以考虑使用堆排序。    
原地排序：堆排序是一个原地排序算法，在排序过程中不需要额外的数组空间，只需要少量的额外空间用于变量存储，因此空间复杂度为 O(1)。     
时间复杂度：堆排序在最好、最坏和平均情况下的时间复杂度都是 O(n log n)，与归并排序相似，但由于它是原地排序，通常会比归并排序使用更少的空间。     
适合大数据集：堆排序特别适合处理大数据集，因为它的时间复杂度相对稳定，并且空间效率高。     

查找第K大（或小）元素：当你需要从未排序的数组中找到第K大（或小）的元素，而不需要对整个数组进行排序时，快速选择是最优选择。    
时间效率要求高：在平均情况下，快速选择的时间复杂度为O(n)，比需要完全排序数组的算法更快。         
空间效率要求高：快速选择算法可以原地进行，除了递归栈，几乎不需要额外的存储空间。           

应用场景对比     
算法题型：如果遇到的是“找到数组中的第k大的元素”这类问题，优先考虑快速选择排序。对于需要合并多个已排序列表或数组，或者需要稳定排序的场景，则归并排序可能是更好的选择。
数据规模与内存限制：面对巨大数据集，特别是那些不能完全加载到内存中的数据，归并排序特别有优势，尤其是其外部排序变体。而快速选择排序适用于寻找中位数或任何特定顺序的元素，而不必对数据进行完全排序。
稳定性考虑：如果题目或数据处理要求稳定性（即相同值的元素排序后保持原来的顺序），归并排序是更好的选择。        


1. 归并排序 (Merge Sort)。   
时间复杂度：    
最好、平均和最坏情况：O(n log n)    

空间复杂度：
O(n)：需要额外的空间来合并两个子数组。    

2. 快速排序 (Quick Sort)    
时间复杂度：     
最好和平均情况：O(n log n)     
最坏情况：O(n^2)（当选择的枢轴是最大或最小元素时）     

空间复杂度：      
O(log n)：虽然快速排序是原地排序，但它需要递归调用栈空间。最优的情况下，空间复杂度为O(log n)，但最坏情况下，如果每次分区只减少一个元素，空间复杂度可以达到O(n)。    

3. 桶排序 (Bucket Sort)     
时间复杂度：     
平均情况：O(n + k)，其中k是桶的数量。    
最坏情况：O(n^2)，当所有元素都分配到同一个桶中时。     

空间复杂度：
O(n + k)：需要额外空间来创建桶，并在桶内存储元素。     

4. 计数排序 (Counting Sort)     
时间复杂度：     
最好、平均和最坏情况：O(n + k)，其中k是输入数据的范围。     
空间复杂度：        
O(k)：需要额外空间来存储计数数组，其中k是输入数据的范围。      

5. 堆排序 (Heap Sort)      
时间复杂度：    
最好、平均和最坏情况：O(nlog n)    
空间复杂度：     
O(1)：堆排序是原地排序算法，除了用于交换的临时变量外，不需要额外的存储空间。       

计数排序更适合于一维的、有限范围的整数排序，而桶排序在处理更复杂分布或需要二维映射关系时更为灵活和有效。

计数排序
计数排序适用于：

数据范围不大的情况，因为它会创建一个计数数组，数组的长度与输入数据的范围有关。
主要处理一维数据，每个数据点都是独立的且可以直接通过映射到计数数组的索引进行排序。
计数排序的优势在于其线性时间复杂度（O(n+k)），但它的空间复杂度也与数据的范围（k）有关，当数据范围很大时可能不太适用。

桶排序
桶排序适用于：

数据分布在一个较广的范围内，但数据分布相对均匀。
需要处理的数据有二维的映射关系，如不仅仅是数值大小，还可能包括数值出现的频率或其他属性。
可以根据数据的特征将数据分配到不同的桶中，每个桶可以独立排序，然后合并结果。

这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

基数排序：根据键值的每位数字来分配桶；
计数排序：每个桶只存储单一键值；
桶排序：每个桶存储一定范围的数值；

