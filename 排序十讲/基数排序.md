考的很少能用基数排序，基本也可以用桶排序。      
```code
//LSD Radix Sort
var counter = [];
function radixSort(arr, maxDigit) {
    var mod = 10;
    var dev = 1;
    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {
        for(var j = 0; j < arr.length; j++) {
            var bucket = parseInt((arr[j] % mod) / dev);
            if(counter[bucket]==null) {
                counter[bucket] = [];
            }
            counter[bucket].push(arr[j]);
        }
        var pos = 0;
        for(var j = 0; j < counter.length; j++) {
            var value = null;
            if(counter[j]!=null) {
                while ((value = counter[j].shift()) != null) {
                      arr[pos++] = value;
                }
          }
        }
    }
    return arr;
}
```

基数排序算法    

基数排序算法。基数排序是一种非比较型整数排序算法，其工作原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。具体来说，它通过每次处理一个数字位，将所有数字分配到相应的桶中（基于当前处理的位），然后按照这个顺序重新组装数字来实现排序。     

基数排序有两种主要的变体：      

LSD（Least Significant Digit first）：先从最低位开始进行排序，逐渐向最高位排序。这种方式在上面的例子中被采用。    
MSD（Most Significant Digit first）：先从最高位开始进行排序，逐渐向最低位排序。这种方式通常用于词典排序，如字符串排 序。      
基数排序的优点是它可以在线性时间内完成排序，时间复杂度为 O(nk)，其中 n 是排序元素的数量，k 是数字的最大位数。它特别适合用于那些位数不是很多的数字排序。不过，基数排序的效率也依赖于内部循环中使用的计数排序或桶排序的实现。此外，基数排序需要额外的空间来存储桶和临时数据，这可能是它的一个缺点。     

LSD   

```code
function radixSortLSD(nums) {
  const max = Math.max(...nums);
  const digits = max.toString().length;
  let radix = 1;

  for (let i = 0; i < digits; i++) {
    let buckets = Array.from({length: 10}, () => []);

    for (let num of nums) {
      const digit = Math.floor((num / radix) % 10);
      buckets[digit].push(num);
    }

    nums = [].concat(...buckets);
    radix *= 10;
  }

  return nums;
}

```

MSD 基数排序   

```code
function radixSortMSD(arr, radixBase = 10, minValue = 0, maxValue = 0, position = 0) {
  if (position < 0 || arr.length <= 1) {
    return arr;
  }

  let buckets = Array.from({length: radixBase}, () => []);
  let radix = Math.pow(radixBase, position);

  for (let i = 0; i < arr.length; i++) {
    if (position === 0) {
      minValue = Math.min(minValue, arr[i]);
      maxValue = Math.max(maxValue, arr[i]);
    }
    let bucketIndex = Math.floor((arr[i] - minValue) / radix) % radixBase;
    buckets[bucketIndex].push(arr[i]);
  }

  if (position === 0) {
    let maxDigit = Math.floor(Math.log10(maxValue - minValue)) + 1;
    return radixSortMSD([].concat(...buckets), radixBase, minValue, maxValue, maxDigit - 1);
  }

  return buckets.reduce((acc, val) => {
    if (val.length > 1) {
      acc.push(...radixSortMSD(val, radixBase, minValue, maxValue, position - 1));
    } else {
      acc.push(...val);
    }
    return acc;
  }, []);
}
```
