## ğŸ“˜ åº·æ‰˜å±•å¼€ & é€†åº·æ‰˜å±•å¼€ç®—æ³•ç¬”è®°ï¼ˆé€šä¿—ç‰ˆï¼‰

---

### ä¸€ã€åº·æ‰˜å±•å¼€ï¼ˆCantor Expansionï¼‰

**åŠŸèƒ½ï¼š** ç»™å®šä¸€ä¸ªæ’åˆ— `[a1, a2, ..., an]`ï¼Œæ±‚å®ƒåœ¨æ‰€æœ‰æ’åˆ—ä¸­å­—å…¸åºçš„æ’åï¼ˆä» 0 å¼€å§‹ï¼‰

#### ğŸ’¡ æ€è·¯ï¼š
- ä»å·¦å¾€å³çœ‹æ¯ä¸ªæ•°
- æ•°ä¸€ä¸‹è¿˜æ²¡å‡ºç°è¿‡çš„ã€æ¯”å®ƒå°çš„æ•°å­—æœ‰å‡ ä¸ªï¼ˆè®°ä¸º `count`ï¼‰
- å®ƒæ’åœ¨å‰é¢ï¼Œä¼šç”Ÿæˆ `count Ã— (å‰©ä¸‹ä½æ•°)!` ä¸ªæ’åˆ—
- æ‰€ä»¥æ€»æ’åæ˜¯è¿™äº›çš„æ€»å’Œ

#### ğŸ§  ç¤ºä¾‹ï¼š[3,1,4,2]
- å…¨æ’åˆ—é•¿åº¦ï¼š4
- æ’å = `2Ã—3! + 0Ã—2! + 1Ã—1! + 0Ã—0! = 13`

#### JS å®ç°ï¼š
```js
function cantorEncode(arr) {
  const n = arr.length;
  const used = Array(n + 1).fill(false);
  const fact = [1];
  for (let i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;

  let rank = 0;
  for (let i = 0; i < n; i++) {
    let cnt = 0;
    for (let j = 1; j < arr[i]; j++) {
      if (!used[j]) cnt++;
    }
    rank += cnt * fact[n - i - 1];
    used[arr[i]] = true;
  }
  return rank;
}
```

---

### äºŒã€é€†åº·æ‰˜å±•å¼€ï¼ˆInverse Cantorï¼‰

**åŠŸèƒ½ï¼š** ç»™å®šä¸€ä¸ªæ’å `rank` å’Œæ’åˆ—é•¿åº¦ `n`ï¼Œè¿˜åŸå‡ºåŸå§‹æ’åˆ—

#### ğŸ’¡ æ€è·¯ï¼š
- ä¸€å¼€å§‹ `nums = [1, 2, ..., n]`
- ç¬¬ i ä½å– `rank / (n - i - 1)!` ä½ç½®çš„æ•°ï¼Œä½œä¸ºè¿™ä¸€ä½çš„æ•°
- åˆ é™¤è¿™ä¸ªæ•°ï¼Œæ›´æ–° rank ä¸º `rank % (n - i - 1)!`
- ç»§ç»­å¾€ä¸‹æ„é€ ä¸‹ä¸€ä½

#### ğŸ§  ç¤ºä¾‹ï¼šrank = 13, n = 4
- å¾—åˆ°ï¼š[3,1,4,2]

#### JS å®ç°ï¼š
```js
function inverseCantor(rank, n) {
  const fact = [1];
  for (let i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;

  const nums = Array.from({ length: n }, (_, i) => i + 1);
  const res = [];
  for (let i = n; i >= 1; i--) {
    const f = fact[i - 1];
    const idx = Math.floor(rank / f);
    res.push(nums[idx]);
    nums.splice(idx, 1);
    rank %= f;
  }
  return res;
}
```

---

### æ€»ç»“å£è¯€ï¼š
```
åº·æ‰˜å±•å¼€ç®—æ’åï¼Œå‰é¢å°æ•°ä¹˜é˜¶ä¹˜
é€†å±•è§£ç å–ä½ç½®ï¼Œé™¤é˜¶ä¹˜ååˆ ä¸‹æ ‡
```

---
