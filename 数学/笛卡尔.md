**95. Unique Binary Search Trees II**

```
function generateTrees(n) {
  if (n === 0) return [];

  function build(start, end) {
    const res = [];

    if (start > end) {
      res.push(null);
      return res;
    }

    for (let i = start; i <= end; i++) {
      const leftTrees = build(start, i - 1);
      const rightTrees = build(i + 1, end);

      for (const left of leftTrees) {
        for (const right of rightTrees) {
          const root = new TreeNode(i);
          root.left = left;
          root.right = right;
          res.push(root);
        }
      }
    }

    return res;
  }

  return build(1, n);
}

```
```
build(1, 3)

i = 1:
  leftTrees = build(1, 0) → [null]
  rightTrees = build(2, 3) → 两种可能：
      2->null->3，3->2->null

  所以根是 1 的有 2 种组合

i = 2:
  leftTrees = build(1,1) → [1]
  rightTrees = build(3,3) → [3]
  → 只有一种组合：2->1,3


```
