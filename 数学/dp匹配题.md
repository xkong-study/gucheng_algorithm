## ✅ 匹配类题目本质总结：画图找路径

匹配类题目（如通配符匹配、正则匹配）虽然不显式是图题，但本质就是：

> **在二维状态表上走路径的过程。**

<img width="415" alt="Screenshot 2025-04-15 at 10 45 07" src="https://github.com/user-attachments/assets/e6e4e93e-1676-42ef-a6fb-df5fa6e96d53" />

只不过：
- 最短路径题：图是题目给的 ✅
- 匹配题：图要你自己画 ❗

---

## 🧩 状态表示

令 `dp[i][j]` 表示：
> s 的前 i 个字符 和 p 的前 j 个字符 是否匹配。

构造的是一个 `(m+1) x (n+1)` 的网格图，从左上角 `(0,0)` 出发，向右向下走，终点是 `(m,n)`。

---

## 🔁 状态转移方向

| pattern 字符 | 状态转移                          | 说明                                               |
|---------------|-----------------------------------|----------------------------------------------------|
| 普通字符      | `dp[i][j] = dp[i-1][j-1]`         | s[i-1] == p[j-1]                                   |
| `?` 或 `.`    | `dp[i][j] = dp[i-1][j-1]`         | 匹配任意单个字符                                   |
| `*`（通配符） | `dp[i][j] = dp[i][j-1] || dp[i-1][j]` | 不匹配字符 or 匹配当前字符继续用 `*`              |
| `*`（正则）   | `dp[i][j] = dp[i][j-2] || (dp[i-1][j] if match)` | 0 次或多次匹配 p[j-2] 前的字符       |

---

## ✅ 初始化边界

- `dp[0][0] = true`：空串与空模式匹配
- 对于 `p` 的前缀全是 `*` 的情况，要预处理 `dp[0][j]`
  - 正则匹配：`dp[0][j] = dp[0][j-2]`
  - 通配匹配：`dp[0][j] = dp[0][j-1]`

---

## 🎯 类比最短路径题

| 最短路径题           | 匹配类题                  |
|------------------------|----------------------------|
| 给定图结构             | 自己构造状态表             |
| 起点 → 终点找最短路径 | 起点 `(0,0)` → `(m,n)` 是否可达 |
| BFS/DP 更新节点       | DP 表更新匹配状态           |

---

## 🧠 总结口诀：

```
匹配问题不抽象，状态转移画方向。
星号斜走也能上，问号配谁都一样。
前缀处理看规则，边界初始化要补全。

图论题图是题给的，匹配题图要你画的。
```

---

如果你把这个图画清楚了，任何匹配题都只是一个“图上的走法问题”。
