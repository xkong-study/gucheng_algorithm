count变量扮演着一个关键角色，它用来跟踪当前窗口是否包含了目标字符串t中的所有唯一字符及其相应的最小数量。具体来说，count的作用和含义如下：

跟踪未满足条件的唯一字符数量：count表示目标字符串t中有多少个不同的字符还没有在当前窗口中以足够的数量出现。初始化时，count设置为t中不同字符的数量。每当某个字符在窗口中的出现次数达到了它在t中的要求次数时，count就减一；反之，如果窗口调整后某个字符的出现次数低于t中的要求，count就增加。

判断窗口是否满足条件：当count为0时，意味着当前窗口已经包含了t中所有不同字符的足够数量，即当前窗口满足条件。在这个状态下，我们可以尝试通过移动窗口的起始边界start来缩小窗口的大小，同时保持窗口满足条件，以寻找可能的最小覆盖子串。

窗口调整时的更新：每次窗口的结束边界end向前移动时，我们会检查新加入的字符是否使得某个字符的计数满足了t中的要求，如果是，count就减一。反之，当窗口的起始边界start向前移动，使得某个字符不再满足t中的要求时（即，其在窗口中的数量少于在t中的数量），count就增加。      

满足条件求最短。   
特殊判断条件用count     
  
```code
var minWindow = function(s, t) {
    if (!s || !t || s.length < t.length) return "";
    
    let tMap = new Map();
    for (let char of t) {
        tMap.set(char, (tMap.get(char) || 0) + 1);
    }

    let count = tMap.size;
    let min = Infinity;
    let ans = "";
    let start = 0;

    for (let end = 0; end < s.length; end++) {
        if (tMap.has(s[end])) {
            tMap.set(s[end], tMap.get(s[end]) - 1);
            if (tMap.get(s[end]) === 0) count--;
        }

        while (count === 0) {
            if (end - start + 1 < min) {
                min = end - start + 1;
                ans = s.substring(start, end + 1);
            }
            
            if (tMap.has(s[start])) {
                tMap.set(s[start], tMap.get(s[start]) + 1);
                if (tMap.get(s[start]) > 0) count++;
            }
            
            start++;
        }
    }

    return ans;
};

```   
