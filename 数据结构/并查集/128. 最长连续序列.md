并查集带着集合大小的模版。        

```code
var longestConsecutive = function(nums) {
    if (nums.length === 0) return 0;
    let indexMap = new Map(); // 存储每个值对应的索引
    let dsu = new DSU(nums.length);
    for(let i = 0; i < nums.length; i++) {
        if(indexMap.has(nums[i])) continue; // 忽略重复元素
        indexMap.set(nums[i], i);
        if(indexMap.has(nums[i] + 1)) {
            dsu.union(i, indexMap.get(nums[i] + 1));
        }
        if(indexMap.has(nums[i] - 1)) {
            dsu.union(i, indexMap.get(nums[i] - 1));
        }
    }

    // 计算最长连续序列的长度
    return dsu.maxSetSize();
};

var DSU = function(size) {
    this.parent = new Array(size);
    this.rank = new Array(size);
    this.size = new Array(size).fill(1); // 新增一个数组来存储集合的大小
    for(let i = 0; i < size; i++) {
        this.parent[i] = i;
        this.rank[i] = 0;
    }
}

DSU.prototype.find = function(x) {
    if(this.parent[x] != x) {
        this.parent[x] = this.find(this.parent[x]);
    }
    return this.parent[x];
}

DSU.prototype.union = function(x, y) {
    let rootX = this.find(x);
    let rootY = this.find(y);
    if(rootX != rootY) {
        if(this.rank[rootX] < this.rank[rootY]) {
            this.parent[rootX] = rootY;
            this.size[rootY] += this.size[rootX];
        } else if(this.rank[rootX] > this.rank[rootY]) {
            this.parent[rootY] = rootX;
            this.size[rootX] += this.size[rootY];
        } else {
            this.parent[rootY] = rootX;
            this.rank[rootX]++;
            this.size[rootX] += this.size[rootY];
        }
    }
}

DSU.prototype.maxSetSize = function() {
    let maxSize = 0;
    for(let i = 0; i < this.size.length; i++) {
        if(this.parent[i] == i) { 
            maxSize = Math.max(maxSize, this.size[i]);
        }
    }
    return maxSize;
}

```
