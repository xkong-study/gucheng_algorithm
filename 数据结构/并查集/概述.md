<img width="863" alt="截屏2024-03-13 20 54 14" src="https://github.com/xkong-study/gucheng_algorithm/assets/100473178/634460fd-757a-44bd-b4da-186d721627a6">

<img width="869" alt="截屏2024-03-13 21 00 57" src="https://github.com/xkong-study/gucheng_algorithm/assets/100473178/c60088ca-6d4f-458d-bc26-aaa217758afa">

<img width="795" alt="截屏2024-03-13 21 35 55" src="https://github.com/xkong-study/gucheng_algorithm/assets/100473178/496868eb-cf0e-4b76-9f68-a7f5106dd4fe">

<img width="816" alt="截屏2024-03-13 21 46 48" src="https://github.com/xkong-study/gucheng_algorithm/assets/100473178/b04b1222-d84a-427d-8b6b-0da8714b4f13">

简单总结：   
1.找祖先。find         
2.合并祖先。union           
3.初始化祖先（祖先是自己）。init    
4.压缩路径（链条=》n叉树）。      


图的连通性问题：在解决图的连通性问题时，经常会使用并查集。例如，在解决网络连接问题、社交网络关系问题等场景中，需要判断两个节点是否在同一个连通分量中。路径压缩可以加速查找根节点的过程，从而提高解决问题的效率。      

最小生成树算法：在 Kruskal 算法等最小生成树算法中，经常需要使用并查集来判断两个节点是否在同一个连通分量中。路径压缩可以优化并查集的性能，加速算法的执行过程。     

动态连通性问题：在解决动态连通性问题时，经常需要使用并查集。例如，处理网络通信中节点的动态加入和退出、网络路由中节点的动态变化等场景，需要实时判断节点之间的连接情况。路径压缩可以提高并查集的查找性能，加速动态连通性问题的解决。       



```code
class DisjointSetUnion {
    constructor(n) {
       // 初始时每个节点的父节点为自己
       this.parent = [];
       for(let i = 0; i < n; i++){
          this.parent[i] = i;
       } 
       this.rank = Array(n).fill(0); // 记录树的深度，用于优化合并操作
    }

    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]); // 路径压缩
        }
        return this.parent[x];
    }

    union(x, y) {
        let rootX = this.find(x);
        let rootY = this.find(y);

        if (rootX === rootY) {
            return; // 已经在同一个集合中，无需合并
        }

        // 按秩合并，即将深度较小的树合并到深度较大的树上
        if (this.rank[rootX] < this.rank[rootY]) {
            this.parent[rootX] = rootY;
        } else if (this.rank[rootX] > this.rank[rootY]) {
            this.parent[rootY] = rootX;
        } else {
            this.parent[rootY] = rootX;
            this.rank[rootX]++;
        }
    }

    isConnected(x, y) {
        return this.find(x) === this.find(y); // 判断两个节点是否在同一个集合中
    }
}

```
让我们通过一个例子来说明。       
  
假设有 5 个节点，编号为 0 到 4，初始时它们都是独立的集合，即每个节点的父节点都是自己，秩（深度）都为 0。       

初始状态下，this.parent 和 this.rank 数组如下所示：           
this.parent = [0, 1, 2, 3, 4]      
this.rank   = [0, 0, 0, 0, 0]      
现在我们执行一系列的合并操作：        

合并节点 0 和节点 1，假设选择将节点 1 合并到节点 0 上，树的深度不变：       
this.parent = [0, 0, 2, 3, 4]      
this.rank   = [1, 0, 0, 0, 0]       
合并节点 2 和节点 3，假设选择将节点 3 合并到节点 2 上，树的深度不变：      

this.parent = [0, 0, 2, 2, 4]      
this.rank   = [1, 0, 1, 0, 0]        
合并节点 1 和节点 4，假设选择将节点 1 合并到节点 4 上，树的深度增加为 1：    

this.parent = [0, 4, 2, 2, 4]    
this.rank   = [1, 0, 1, 0, 1]     
现在，节点 0 和节点 4 在同一个集合中，其余节点在各自的集合中。在这个过程中，this.rank 数组中的值根据合并操作的具体情况得到了更新，以反映树的实际深度。    


所以现在树的深度是多少？    

现在树的深度如下：    

以节点 0 为根的树的深度为 1。      
以节点 1 为根的树的深度为 0。       
以节点 2 为根的树的深度为 1。      
以节点 3 为根的树的深度为 0。     
以节点 4 为根的树的深度为 1。     
这个状态下，并查集中共有 3 棵树，每棵树的深度分别为 1、1 和 1。       





