这个数据结构难的不是怎么实现，难的是边界条件。      

<img width="817" alt="截屏2024-03-17 14 30 19" src="https://github.com/xkong-study/gucheng_algorithm/assets/100473178/05f6a42b-f57d-42c5-9b5c-c741a9443fbd">

<img width="882" alt="截屏2024-03-17 14 33 06" src="https://github.com/xkong-study/gucheng_algorithm/assets/100473178/6e854b18-8916-4434-8b29-3b7b07745fbd">

<img width="890" alt="截屏2024-03-17 14 34 36" src="https://github.com/xkong-study/gucheng_algorithm/assets/100473178/ccac03c3-7f76-47e1-8f87-f5230fdef500">

<img width="836" alt="截屏2024-03-18 15 55 31" src="https://github.com/xkong-study/gucheng_algorithm/assets/100473178/9df02416-71fc-4e75-bd0f-f8928ed89b45">

解析：    
1.在数据结构中stack（栈）和queue（队列）的读写密集型的概念。   

Write heavy（写密集型）: 这意味着在这些问题中，栈或队列会频繁地进行push或enqueue操作。如果一个算法题目主要考查如何高效地添加元素到数据结构中，而对如何从中读取数据的要求相对较少，那么这个问题可以被认为是写密集型的。在这种情况下，你可能需要关注如何优化数据结构的扩容机制、内存分配和复制操作。       

Read heavy（读密集型）: 如果问题主要涉及读取操作，如频繁的pop、dequeue或者访问操作，并且这些读取操作比添加或者删除操作更复杂或者更频繁，那么这个问题被认为是读密集型的。在设计读密集型的栈或队列时，你可能需要优化查找特定元素的时间复杂度，或者增加索引结构来快速访问元素。     

下面是一些可能读密集型的优化策略：      

辅助哈希表：例如，如果你需要快速检索栈中的特定元素，你可以使用一个哈希表来存储值到它们在栈中位置的映射。这样，你可以在 O(1) 时间复杂度内找到任何元素在栈中的位置。     

最小/最大值栈：如果你经常需要访问栈中的最小或最大值，你可以维护一个辅助栈，每次元素入主栈时，你也将目前主栈的最小（或最大）值放入辅助栈。这样，你总是可以在 O(1) 时间内访问到最小或最大值。      

双端队列（deque）：在队列中，如果你需要在两端都能进行高效的插入和删除操作，双端队列（deque）就很有用。它允许你在 O(1) 时间复杂度内在队列的前端和后端进行添加和移除操作。     

优先队列：如果你经常需要访问队列中优先级最高或最低的元素，优先队列或者二叉堆可以让你在 O(log n) 时间内插入元素，并在 O(1) 时间内访问到优先级最高的元素。      


下面是一些可能写密集型的优化策略：      

动态数组（如ArrayList或std::vector）:        

动态数组只在数组需要扩容时才进行内存分配，而且这样的操作通常是以摊销常数时间进行的（也就是说，尽管单次扩容可能花费较长时间，但每项操作的平均成本仍然是常数时间）。    
在某些实现中，当数组增长时，它会按照当前大小的一定比例（例如，每次增长50%或100%）来分配额外的空间，这样可以减少扩容操作的频率。    

链表:    

如果栈的使用模式除了写密集外，还包括频繁的大小变化（即频繁的入栈和出栈），那么使用链表可以避免动态数组扩容时可能的大量元素复制。   
链表的每个节点分配可能会导致更多的内存管理开销，但如果这些节点是预先分配或者通过内存池管理的，这种开销可以被显著减少。    


