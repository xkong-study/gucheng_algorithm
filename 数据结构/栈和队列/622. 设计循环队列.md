对头插入、对头删除是循环队列的基本操作。在循环队列中，元素从对尾插入，从对头删除。这种设计可以保持队列的头尾指针的相对位置不变，使得入队和出队操作的时间复杂度都是 O(1)，而不会因为移动元素而变得复杂。     

循环必备写法：        

```code
let tailIndex = (this.rear - 1 + this.capacity) % this.capacity;
return this.arr[tailIndex]
```

为什么以后要空出来一个格子，因为不这样写的话空和满的两个条件就长一样了，无法分清。      

```code
var MyCircularQueue = function(k) {
this.arr = [];
this.rear = 0;
this.front = 0;
this.capacity = k+1;
};

/** 
 * @param {number} value
 * @return {boolean}
 */
MyCircularQueue.prototype.enQueue = function(value) {
if (this.isFull()) return false;
this.arr[this.rear] = value;
this.rear = (this.rear+1)%this.capacity;
return true;
};

/**
 * @return {boolean}
 */
MyCircularQueue.prototype.deQueue = function() {
    if (this.isEmpty()) return false;
    this.front = (this.front + 1) % this.capacity;
    return true;
};


/**
 * @return {number}
 */
MyCircularQueue.prototype.Front = function() {
if (this.isEmpty()) return -1;
return this.arr[this.front];
};

/**
 * @return {number}
 */
MyCircularQueue.prototype.Rear = function() {
if (this.isEmpty()) return -1;
let tailIndex = (this.rear - 1 + this.capacity) % this.capacity;
return this.arr[tailIndex];
};

/**
 * @return {boolean}
 */
MyCircularQueue.prototype.isEmpty = function() {
return this.rear == this.front;
};

/**
 * @return {boolean}
 */
MyCircularQueue.prototype.isFull = function() {
if((this.rear+1)%this.capacity == this.front) return true;
return false;
};
```
