辅助栈 （单调递减栈）。             

https://github.com/xkong-study/gucheng_algorithm/assets/100473178/5ad4ac98-ac0e-497f-84c4-832fdc79a994

我以前写的是一个栈一个优先队列。但是我看标准答案都一个栈一个辅助栈。重新写吧      

复杂度分析：

时间复杂度 O(1) ：压栈，出栈，获取最小值的时间复杂度都为 O(1)O(1)O(1) 。
空间复杂度 O(N)) ：包含 NNN 个元素辅助栈占用线性大小的额外空间。

确实时间复杂度变低了
优先队列是二叉树，二叉树的搜索都是一分为二所以是logn.     
插入元素：O(log n)     
删除最大（或最小）元素：O(log n)     
获取最大（或最小）元素：O(1)      


所以不要用优先队列用辅助栈。    


```code
在push方法中更新min_stack
当新元素val小于或等于min_stack的栈顶元素时，应该将新元素val推入min_stack。这是因为新元素可能与当前最小值相同，此时如果只在小于时推入，会导致在执行pop操作时无法正确同步min_stack和stack。

var MinStack = function() {
this.stack = [];
this.min_stack = [];
};

/** 
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function(val) {
this.stack.push(val);
if (this.min_stack.length === 0 || val <= this.min_stack[this.min_stack.length - 1]) {
        this.min_stack.push(val);
    }
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
let val = this.stack.pop();
if(this.min_stack[this.min_stack.length-1] == val) this.min_stack.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
return this.stack[this.stack.length-1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
return this.min_stack[this.min_stack.length - 1];
};

```
