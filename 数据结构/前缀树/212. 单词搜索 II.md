把每一个格子作为起点然后上下左右寻找有没有满足条件的情况。 dfs(trie.children, i, j, '');          
trie.children：传入 Trie 树的根节点的子节点，这是因为 Trie 树的根节点自身通常不存储字符，而其子节点存储了第一层的所有可能字符。     

```code
var findWords = function(board, words) {
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    let trie = new Trie();
    let ans = new Set(); 
    for (let word of words) {
        trie.insert(word);
    }

    let rows = board.length;
    let cols = board[0].length;
    let visited = Array.from({ length: rows }, () => Array(cols).fill(false));
    function dfs(row, col, prefix, node) {
        if (node.isEnd) {
            ans.add(prefix); 
        }

        visited[row][col] = true;

        for (const [dx, dy] of directions) {
            let newRow = row + dx;
            let newCol = col + dy;

            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !visited[newRow][newCol]) {
                let nextChar = board[newRow][newCol];
                if (node.children[nextChar]) {
                    dfs(newRow, newCol, prefix + nextChar, node.children[nextChar]);
                }
            }
        }
        visited[row][col] = false;
    }

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            let char = board[r][c];
            if (trie.children[char]) {
                dfs(r, c, char, trie.children[char]);
            }
        }
    }
    return Array.from(ans);
};

var Trie = function() {
    this.children = {};
    this.isEnd = false;
}

Trie.prototype.insert = function(word) {
    let node = this;
    for (const char of word) {
        if (!node.children[char]) {
            node.children[char] = new Trie();
        }
        node = node.children[char];
    }
    node.isEnd = true;
}
```
