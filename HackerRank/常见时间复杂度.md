# 🚀 HackerRank 常见询问算法的时间复杂度

在 HackerRank 题目中，经常需要 **优化算法的时间复杂度**，以下是常见 **算法的时间复杂度** 以及 **什么时候使用它们**。

---

## **📌 1. 基本运算**
| **操作** | **时间复杂度** | **适用情况** |
|----------|--------------|--------------|
| 赋值 `x = y` | **O(1)** | 变量赋值或修改 |
| 加法 / 乘法 `a + b` / `a * b` | **O(1)** | 数值计算 |
| 访问数组元素 `arr[i]` | **O(1)** | 直接访问索引 |
| 哈希表查找 `map[key]` | **O(1)** | 常数时间哈希查找 |

---

## **📌 2. 排序**
| **排序算法** | **时间复杂度** | **适用情况** |
|--------------|--------------|--------------|
| 选择排序 / 冒泡排序 | **O(N²)** | 只适用于 **小规模数据** |
| 归并排序 | **O(N log N)** | 适用于 **稳定排序** |
| 快速排序（随机选择） | **O(N log N)** | 适用于 **大规模数据** |
| 计数排序 / 基数排序 | **O(N + K)** | 适用于 **整数排序，K 为数据范围** |
| 堆排序 | **O(N log N)** | 适用于 **优先队列排序** |

---

## **📌 3. 搜索**
| **搜索算法** | **时间复杂度** | **适用情况** |
|-------------|--------------|--------------|
| 线性搜索 | **O(N)** | **无序数据** |
| 二分查找 | **O(log N)** | **必须排序数组** |
| BFS / DFS | **O(N + M)** | **遍历图或网格** |
| Dijkstra（最短路径） | **O((N + M) log N)** | **带权图最短路径** |
| Bellman-Ford（单源最短路径） | **O(NM)** | **适用于负权图** |
| Floyd-Warshall（全源最短路径） | **O(N³)** | **适用于小规模图** |

---

## **📌 4. 数据结构查询**
| **数据结构** | **插入** | **查询** | **删除** | **适用情况** |
|-------------|---------|---------|---------|--------------|
| 数组 | **O(1)** | **O(1)** | **O(N)** | 适用于 **固定大小数据** |
| 链表 | **O(1)** | **O(N)** | **O(1)** | 适用于 **动态插入删除** |
| 哈希表 | **O(1)** | **O(1)** | **O(1)** | 适用于 **键值存储** |
| 堆 / 优先队列 | **O(log N)** | **O(1) / O(log N)** | **O(log N)** | 适用于 **动态获取最大 / 最小值** |
| 线段树 | **O(log N)** | **O(log N)** | **O(log N)** | 适用于 **区间查询 / 修改** |

---

## **📌 5. 动态规划（DP）**
| **问题类型** | **时间复杂度** | **适用情况** |
|-------------|--------------|--------------|
| 斐波那契数列（记忆化） | **O(N)** | **避免指数递归** |
| 背包问题 | **O(N * W)** | **0/1 背包 & 完全背包** |
| 最长公共子序列（LCS） | **O(N * M)** | **字符串匹配问题** |
| 矩阵连乘 | **O(N³)** | **区间 DP** |

---

## **📌 6. 取模 / 组合数学**
| **算法** | **时间复杂度** | **适用情况** |
|---------|--------------|--------------|
| 计算 `(a^b) % mod` | **O(log B)** | **快速幂** |
| 计算 `n! % mod` | **O(N)** | **预计算阶乘** |
| 计算 `C(n, k) % mod` | **O(N)** | **预计算逆元** |

---

## **📌 7. 近似计算**
| **问题** | **时间复杂度** | **适用情况** |
|---------|--------------|--------------|
| 质数判断（试除法） | **O(sqrt N)** | **小范围质数检测** |
| 质数筛选（埃氏筛法） | **O(N log log N)** | **预处理范围内质数** |
| 质因数分解 | **O(sqrt N)** | **因子分解** |
| 计算 `gcd(a, b)` | **O(log min(a, b))** | **欧几里得算法** |

---

## **🚀 速查指南**
| **操作 / 问题** | **推荐算法** | **时间复杂度** |
|----------------|------------|--------------|
| **查询最大/最小** | **堆 / 线段树** | **O(log N)** |
| **搜索一个元素** | **二分查找（已排序）** | **O(log N)** |
| **寻找最短路径** | **Dijkstra / BFS** | **O((N + M) log N) / O(N + M)** |
| **找 `a^b % mod`** | **快速幂** | **O(log B)** |
| **找 `n! % mod`** | **预计算阶乘** | **O(N)** |

---

## **🔥 总结**
1. **优先选择 `O(N log N)` 或 `O(N)` 的方法**
2. **避免 `O(N²)` 或 `O(2^N)` 级别的算法**
3. **掌握 `O(log N)` 二分查找、`O(N log N)` 排序、`O(1)` 哈希查询**
4. **理解数据结构（哈希表、堆、树）如何影响时间复杂度**
5. **数学计算时，避免溢出，使用 `mod 10^9 + 7`**

🚀 **掌握这些时间复杂度，你可以更快地优化 HackerRank 代码！** 🔥
