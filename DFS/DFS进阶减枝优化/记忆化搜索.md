什么时候用到记忆化搜索：多重递归路径导致产生重复子问题           

1.相同索引的时候。    

在处理像 "111111" 这样的字符串时，由于每个位置可以通过两种方式解析（解析1位或2位），会导致在递归过程中产生大量的重叠子问题。这正是记忆化发挥作用的理想场景。      

举例：     
从索引0开始解析 "111111":     
解析 "1"，剩余 "11111"。     
解析 "11"，剩余 "1111"。       
解析 "111"，剩余 "111"。      

对 "11111" 从索引1开始解析:      
解析 "1"，剩余 "1111"（从索引2开始）。     
解析 "11"，剩余 "111"（从索引3开始）。   

对 "1111" 从索引2开始解析：       
解析 "1"，剩余 "111"（从索引3开始）。     
解析 "11"，剩余 "11"（从索引4开始）。       

这里索引3就执行了两次，那么就可以进行记忆化的存储。            


dfs解题思考：        
1.识别决策点的分支数量：首先，确定每个决策点有多少个可行的选择路径。这可能是单一路径、两条路径，或者是多条路径，需要通过循环来遍历。               
2.判断路径的唯一性：对于每一个选择的路径，检查是否已经在之前的搜索中考虑过。如果这些路径在之前的决策点中已被探索，我们可以使用记忆化搜索以避免重复计算；如果未被探索过，则继续进行深度搜索。             
3.确定搜索的维度：判断需要执行的是一维DFS还是二维DFS。这取决于问题的具体情况，比如是需要在数组中寻找子集，还是处理类似“几个人每个人带多少帽子”这样的多维情景。                
