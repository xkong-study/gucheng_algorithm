很简单：就是index记录有几个位置，i用来表示有多少人想坐这个位置。i==index的时候位置够的直接坐就好，位置不够的话那么相同的数字就不能出现两次




这种题，我以前都直接背模版根本就不懂为什么避免子节点重复为什么可以if(i>index && nums[i] == nums[i-1]) continue 这样写实现。    
经过我昨天的呕心沥血，终于明白了。  

```code
var subsetsWithDup = function(nums) {
let ans = [];
nums.sort((a,b)=>a-b)
function dfs(index,queue){
if(queue) ans.push([...queue]);
for(let i=index;i<nums.length;i++){
    从这里
    if(i>index && nums[i] == nums[i-1]) continue
    queue.push(nums[i]);
    到这里：在找所有可能子节点=》为什么要i>index：当前层级的当前头节点索引为index，剩下的是当前头节点后面所有可能的子节点所以i>index就是他后面所有可能的子节点不可以有重复的子节点
    dfs(i+1,queue); 这里：往后找当前子节点后面可能的集合
    queue.pop();
}
}
dfs(0,[]);
return ans;
};
```
比如说我在概述里面举的例子：    
```code
循环起点: 0 当前队列: [ 1 ] 后面的子节点: 1 递归树的一个节点开始探索所有可能的子路径
循环起点: 1 当前队列: [ 1, 2 ] 后面的子节点: 2 递归树的一个节点开始探索所有可能的子路径
循环起点: 2 当前队列: [ 1, 2, 3 ] 后面的子节点: 3 递归树的一个节点开始探索所有可能的子路径
循环起点: 1 当前队列: [ 1, 3 ] 后面的子节点: 3 递归树的一个节点开始探索所有可能的子路径
循环起点: 0 当前队列: [ 2 ] 后面的子节点: 2 递归树的一个节点开始探索所有可能的子路径
循环起点: 2 当前队列: [ 2, 3 ] 后面的子节点: 3 递归树的一个节点开始探索所有可能的子路径
循环起点: 0 当前队列: [ 3 ] 后面的子节点: 3 递归树的一个节点开始探索所有可能的子路径
```
循环起点0:当前队列都是1打头，然后递增往后找所有可能的子节点。    

我感觉dfs就是递归找到每一个递归层级所有可能的子节点，找完了返回上一层级。    
