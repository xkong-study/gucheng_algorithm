这种题，我以前都直接背模版根本就不懂为什么避免子节点重复为什么可以if(i>index && nums[i] == nums[i-1]) continue 这样写实现。    
经过我昨天的呕心沥血，终于明白了。  

```code
var subsetsWithDup = function(nums) {
let ans = [];
nums.sort((a,b)=>a-b)
function dfs(index,queue){
if(queue) ans.push([...queue]);
for(let i=index;i<nums.length;i++){
    从这里
    if(i>index && nums[i] == nums[i-1]) continue
    queue.push(nums[i]);
    到这里：在找所有可能子节点=》为什么要i>index：当前层级的当前头节点索引为index，剩下的是当前头节点后面所有可能的子节点所以i>index就是他后面所有可能的子节点不可以有重复的子节点
    dfs(i+1,queue); 这里：往后找当前子节点后面可能的集合
    queue.pop();
}
}
dfs(0,[]);
return ans;
};
```
