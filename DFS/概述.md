<img width="675" alt="截屏2024-03-27 10 38 00" src="https://github.com/xkong-study/gucheng_algorithm/assets/100473178/515edc02-cf60-4676-be26-af7b9ab18f06">

每次遇到dfs题目都是直接套用模版写，对dfs的递归过程基本就像盲盒一样，我今天花了一天时间理解这个dfs的整个过程.         

```code
var subsets = function(nums) {
    let ans = [];
    function dfs(queue, index){
        queue && ans.push([...queue]);
        console.log(queue, index, '开始执行一个新的递归层级');
        for(let i = index; i < nums.length; i++){
            queue.push(nums[i]);
            console.log('循环起点:', index, '当前队列:', queue, '后面的子节点:', i + 1, '递归树的一个节点开始探索所有可能的子路径');
            dfs(queue, i + 1);
            console.log('回溯起点:', index, '当前队列:', queue, '后面的子节点:', i + 1, '节点的所有子节点都被探索过后，开始回溯探索其他可能的子集');
            queue.pop();
        }
    }
    dfs([], 0);
    return ans;
};
```
for循环是为了找出所有子节点。递归是找到该节点下的所有可能子集。子集找完了就回溯，for让他接着往下找新的子节点。新的子节点全部找完了也回溯。               

```code
[] 0 开始执行一个新的递归层级
循环起点: 0 当前队列: [ 1 ] 后面的子节点: 1 递归树的一个节点开始探索所有可能的子路径
[ 1 ] 1 开始执行一个新的递归层级
循环起点: 1 当前队列: [ 1, 2 ] 后面的子节点: 2 递归树的一个节点开始探索所有可能的子路径
[ 1, 2 ] 2 开始执行一个新的递归层级
循环起点: 2 当前队列: [ 1, 2, 3 ] 后面的子节点: 3 递归树的一个节点开始探索所有可能的子路径
[ 1, 2, 3 ] 3 开始执行一个新的递归层级
回溯起点: 2 当前队列: [ 1, 2, 3 ] 后面的子节点: 3 节点的所有子节点都被探索过后，开始回溯探索其他可能的子集
回溯起点: 1 当前队列: [ 1, 2 ] 后面的子节点: 2 节点的所有子节点都被探索过后，开始回溯探索其他可能的子集
循环起点: 1 当前队列: [ 1, 3 ] 后面的子节点: 3 递归树的一个节点开始探索所有可能的子路径
[ 1, 3 ] 3 开始执行一个新的递归层级
回溯起点: 1 当前队列: [ 1, 3 ] 后面的子节点: 3 节点的所有子节点都被探索过后，开始回溯探索其他可能的子集
回溯起点: 0 当前队列: [ 1 ] 后面的子节点: 1 节点的所有子节点都被探索过后，开始回溯探索其他可能的子集
循环起点: 0 当前队列: [ 2 ] 后面的子节点: 2 递归树的一个节点开始探索所有可能的子路径
[ 2 ] 2 开始执行一个新的递归层级
循环起点: 2 当前队列: [ 2, 3 ] 后面的子节点: 3 递归树的一个节点开始探索所有可能的子路径
[ 2, 3 ] 3 开始执行一个新的递归层级
回溯起点: 2 当前队列: [ 2, 3 ] 后面的子节点: 3 节点的所有子节点都被探索过后，开始回溯探索其他可能的子集
回溯起点: 0 当前队列: [ 2 ] 后面的子节点: 2 节点的所有子节点都被探索过后，开始回溯探索其他可能的子集
循环起点: 0 当前队列: [ 3 ] 后面的子节点: 3 递归树的一个节点开始探索所有可能的子路径
[ 3 ] 3 开始执行一个新的递归层级
回溯起点: 0 当前队列: [ 3 ] 后面的子节点: 3 节点的所有子节点都被探索过后，开始回溯探索其他可能的子集
```


for循环是为了找出所有子节点。    
```code
循环起点: 0 当前队列: [ 1 ] 后面的子节点: 1 递归树的一个节点开始探索所有可能的子路径
循环起点: 1 当前队列: [ 1, 2 ] 后面的子节点: 2 递归树的一个节点开始探索所有可能的子路径
循环起点: 2 当前队列: [ 1, 2, 3 ] 后面的子节点: 3 递归树的一个节点开始探索所有可能的子路径
循环起点: 1 当前队列: [ 1, 3 ] 后面的子节点: 3 递归树的一个节点开始探索所有可能的子路径
循环起点: 0 当前队列: [ 2 ] 后面的子节点: 2 递归树的一个节点开始探索所有可能的子路径
循环起点: 2 当前队列: [ 2, 3 ] 后面的子节点: 3 递归树的一个节点开始探索所有可能的子路径
循环起点: 0 当前队列: [ 3 ] 后面的子节点: 3 递归树的一个节点开始探索所有可能的子路径
```
子节点当前队列1，2，3 头节点在递增是不是。    
```code
循环起点: 0 当前队列: [ 1 ] 后面的子节点: 1 递归树的一个节点开始探索所有可能的子路径
循环起点: 0 当前队列: [ 2 ] 后面的子节点: 2 递归树的一个节点开始探索所有可能的子路径
循环起点: 0 当前队列: [ 3 ] 后面的子节点: 3 递归树的一个节点开始探索所有可能的子路径   
```
通过观察确实可以发现相同的循环地点当前队列的子节点确实是在递增，这个就是for循环起到的作用。    

回溯就是=》子节点的集合结束了，回溯（判断条件：i>=nums.length）    


```code
DFS的操作流程和状态变化：

1. 调用DFS函数
   ├─── 索引i初始化为0 (表示开始位置或第一个元素)
   ├─── 深度level初始化为0 (表示递归的层级)
   └─── 访问标记visited初始化（仅全排列问题中使用）

2. 进入新的递归层级
   ├─── 索引i递增 (i++)
   ├─── 深度level递增 (level++)
   └─── 访问标记visited[i]设为true (全排列问题中)

3. 递归终止条件检查
   ├─── 如果i达到数组长度，处理当前组合或排列
   └─── 返回结果或进行下一步操作

4. 回溯到上一层
   ├─── 索引i递减 (i--)
   ├─── 深度level递减 (level--)
   └─── 访问标记visited[i]设为false (全排列问题中，撤销选择)

5. 重复步骤2-4直到所有可能的组合或排列被探索完毕
```

<img width="628" alt="截屏2024-04-25 11 32 37" src="https://github.com/xkong-study/gucheng_algorithm/assets/100473178/859a91e0-9f66-4ae3-a227-93c853a23166">


