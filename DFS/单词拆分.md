这道题如果单纯用dfs解题是会超时的，姐子们！！！！！！！
```code
var wordBreak = function(s, wordDict) {
    let res = [];
    let memo = {};

    function dfs(start, queue) {
        let key = start + '-' + queue.join('');
        if (memo[key]) {
            return;
        }

        if (start == s.length && queue.join('') == s) {
            res.push(queue.join(''));
            return;
        }

        for (let i = start; i < s.length; i++) {
            if (wordDict.includes(s.slice(start, i + 1))) {
                queue.push(s.slice(start, i + 1));
                dfs(i + 1, queue);
                queue.pop();
            }
        }
        memo[key] = true;
    }

    dfs(0, []);
    return res;
};

```

所以一定要加入记忆化

```code
var wordBreak = function(s, wordDict) {
    const memo = {}; // 记忆化对象

    function dfs(i, str) {
        if (i === s.length) {
            return true;
        }

        // 检查记忆化结果
        if (memo.hasOwnProperty(str)) {
            return memo[str];
        }

        for (let j = i + 1; j <= s.length; j++) {
            if (wordDict.includes(s.slice(i, j))) {
                if (dfs(j, str + s.slice(i, j))) {
                    // 更新记忆化结果并返回
                    memo[str] = true;
                    return true;
                }
            }
        }

        // 更新记忆化结果并返回
        memo[str] = false;
        return false;
    }

    return dfs(0, '');
};

```
在JavaScript中：

includes 主要用于数组和字符串，检查数组中是否包含某个元素或者字符串中是否包含某个子串。对于对象而言，是不能直接使用 includes 的。

hasOwnProperty 是 JavaScript 对象的方法，用于检查对象是否包含指定的属性。在记忆化中，通过 memo.hasOwnProperty(key) 来判断记忆化对象中是否已经保存了某个状态。

对于 Map 对象，有 has 方法用于判断是否包含指定的键。

在记忆化中，通过使用对象（或 Map）来保存已经计算过的状态，避免重复计算，提高算法效率。
