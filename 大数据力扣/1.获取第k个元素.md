# 📌 堆排序可能出的 LeetCode 题目及 Follow-up

## 🔹 1. 可能涉及堆排序的 LeetCode 题目

### **Top K 相关**
- **[LeetCode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/)** - **数组中的第K个最大元素**
- **[LeetCode 973](https://leetcode.com/problems/k-closest-points-to-origin/)** - **最接近原点的 K 个点**
- **[LeetCode 347](https://leetcode.com/problems/top-k-frequent-elements/)** - **前 K 个高频元素**

### **动态中位数**
- **[LeetCode 295](https://leetcode.com/problems/find-median-from-data-stream/)** - **数据流的中位数**

### **区间合并 / 日程安排**
- **[LeetCode 253](https://leetcode.com/problems/meeting-rooms-ii/)** - **会议室 II**
- **[LeetCode 621](https://leetcode.com/problems/task-scheduler/)** - **任务调度器**

### **合并 K 个排序链表**
- **[LeetCode 23](https://leetcode.com/problems/merge-k-sorted-lists/)** - **合并 K 个排序链表**

### **堆排序模拟**
- **[LeetCode 378](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)** - **有序矩阵中的第 K 小元素**
- **[LeetCode 1046](https://leetcode.com/problems/last-stone-weight/)** - **最后一块石头的重量**
- **[LeetCode 1648](https://leetcode.com/problems/sell-diminishing-valued-colored-balls/)** - **销售价值减少的颜色球**

---

## 🔹 2. 可能的 Follow-up 问题

### **🟢 1. 如果数据规模特别大（10 亿个元素），如何优化？**
- **方案**：
  - **外部排序（External Sorting）**
  - **最小堆维护流式数据**
  - **分块处理 + 归并排序**

---

### **🟢 2. 堆排序 vs 快速选择（QuickSelect）**
| 算法 | 时间复杂度 | 适用场景 |
|------|----------|---------|
| **堆排序（Heap Sort）** | \(O(n \log k)\) | **多次查询 Top-K** |
| **快速选择（QuickSelect）** | \(O(n)\)（平均） | **一次性查找 K-th** |

---

### **🟢 3. 堆排序能否做到 O(n) 时间？**
- **建堆可以 O(n)**，但排序仍是 **O(n log n)**
- **优化建堆公式**:
  \[
  \sum_{i=1}^{\log n} \frac{n}{2^i} i = O(n)
  \]

---

### **🟢 4. 手写堆排序**
#### **JavaScript 代码**
```javascript
function heapSort(arr) {
    const n = arr.length;

    // 建堆
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // 逐步交换堆顶与末尾元素，并重新堆化
    for (let i = n - 1; i > 0; i--) {
        [arr[0], arr[i]] = [arr[i], arr[0]];
        heapify(arr, i, 0);
    }
}

function heapify(arr, n, i) {
    let largest = i, left = 2 * i + 1, right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;

    if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];
        heapify(arr, n, largest);
    }
}

// 测试
let nums = [3, 1, 4, 1, 5, 9, 2, 6, 5];
heapSort(nums);
console.log(nums); // [1, 1, 2, 3, 4, 5, 5, 6, 9]
```

### **🟢 5. LeetCode 215（Kth Largest）如何用堆优化？**
#### **最小堆优化（O(n log k)）**
```javascript
function findKthLargest(nums, k) {
    let minHeap = new MinPriorityQueue();

    for (let num of nums) {
        minHeap.enqueue(num);
        if (minHeap.size() > k) {
            minHeap.dequeue();
        }
    }
    return minHeap.front().element;
}

```
### **🟢 6. 合并 K 个排序链表，能优化到 O(n log k) 吗？**
#### **最小堆解法**
```javascript
function mergeKLists(lists) {
    let minHeap = new MinPriorityQueue({ priority: x => x.val });

    for (let list of lists) {
        if (list) minHeap.enqueue(list);
    }

    let dummy = new ListNode(-1), cur = dummy;

    while (!minHeap.isEmpty()) {
        let node = minHeap.dequeue().element;
        cur.next = node;
        cur = node;
        if (node.next) minHeap.enqueue(node.next);
    }

    return dummy.next;
}
```

## 🔹 3. 重点总结
- **堆排序适用于** Top-K 问题，动态中位数，合并 K 个排序链表
- **堆排序 vs 快速选择（QuickSelect）**，取决于查询次数
- **大规模数据：** 外部排序（External Sorting）+ K 路归并
- **优化时间复杂度：**
  - **建堆：** \(O(n)\)
  - **整体排序：** \(O(n \log n)\)

如果面试遇到 **Top-K、动态中位数、数据流、合并 K 个链表** 等问题，**多考虑堆（Heap）和堆排序（Heap Sort）！** 🚀


